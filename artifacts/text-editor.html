<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Writing Assistant</title>
    <!-- Google Fonts: Inter -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --accent: #00FFD0;
            --bg: #fff;
            --bg-alt: #f6f7f9;
            --border: #e3e6ea;
            --text: #222;
            --text-light: #888;
            --card-radius: 18px;
            --shadow: 0 2px 16px 0 rgba(0,0,0,0.04);
            --icon-size: 20px;
        }
        html, body {
            background: var(--bg);
            color: var(--text);
            font-family: 'Inter', Arial, sans-serif;
            font-size: 16px;
            margin: 0;
            padding: 0;
            min-height: 100vh;
        }
        body {
            margin: 0;
            padding: 0;
        }
        .container {
            max-width: 1100px;
            margin: 0 auto;
            padding: 32px 16px;
        }
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 36px;
        }
        .header-title {
            font-size: 2.2rem;
            font-weight: 700;
            letter-spacing: -1px;
            display: flex;
            align-items: center;
            gap: 12px;
        }
        .header-accent {
            width: 32px;
            height: 32px;
            border-radius: 8px;
            background: var(--accent);
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .header-controls {
            display: flex;
            align-items: center;
            gap: 18px;
        }
        .select, .input {
            font-family: inherit;
            font-size: 1rem;
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 7px 14px;
            background: var(--bg);
            color: var(--text);
            outline: none;
            transition: border 0.2s;
        }
        .select:focus, .input:focus {
            border-color: var(--accent);
        }
        .toggle-btn {
            background: var(--bg-alt);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 7px 10px;
            cursor: pointer;
            transition: border 0.2s, background 0.2s;
            display: flex;
            align-items: center;
        }
        .toggle-btn:hover {
            border-color: var(--accent);
            background: #eafffa;
        }
        .main-grid {
            display: grid;
            grid-template-columns: 1fr 340px;
            gap: 32px;
        }
        @media (max-width: 900px) {
            .main-grid {
                grid-template-columns: 1fr;
            }
        }
        .card {
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: var(--card-radius);
            box-shadow: var(--shadow);
            padding: 32px 28px 24px 28px;
            margin-bottom: 0;
        }
        .editor-toolbar {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 18px;
        }
        .toolbar-btn {
            background: none;
            border: none;
            padding: 6px;
            border-radius: 6px;
            cursor: pointer;
            display: flex;
            align-items: center;
            transition: background 0.15s;
        }
        .toolbar-btn:hover, .toolbar-btn:focus {
            background: #eafffa;
        }
        .toolbar-btn svg {
            width: var(--icon-size);
            height: var(--icon-size);
            stroke: var(--text-light);
            transition: stroke 0.2s;
        }
        .toolbar-btn:hover svg, .toolbar-btn:focus svg {
            stroke: var(--accent);
        }
        .editor {
            min-height: 320px;
            max-height: 420px;
            overflow-y: auto;
            border: 1.5px solid var(--border);
            border-radius: 12px;
            padding: 18px 16px;
            font-size: 1.08rem;
            font-family: inherit;
            background: var(--bg-alt);
            margin-bottom: 18px;
            outline: none;
            transition: border 0.2s;
        }
        .editor:focus {
            border-color: var(--accent);
        }
        .editor-toolbar .select {
            min-width: 90px;
        }
        .editor-toolbar .select, .editor-toolbar .input {
            margin-right: 8px;
        }
        .editor-actions {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 10px;
        }
        .btn-accent {
            background: var(--accent);
            color: #000;
            border: none;
            border-radius: 8px;
            padding: 10px 24px;
            font-weight: 600;
            font-size: 1rem;
            cursor: pointer;
            box-shadow: 0 2px 8px 0 rgba(0,255,208,0.08);
            transition: background 0.18s, color 0.18s;
        }
        .btn-accent:hover, .btn-accent:focus {
            background: #00e6ba;
            color: #111;
        }
        .char-count {
            font-size: 0.98rem;
            color: var(--text-light);
        }
        .suggestions-panel {
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: var(--card-radius);
            box-shadow: var(--shadow);
            padding: 28px 20px 20px 20px;
            min-height: 320px;
        }
        .suggestions-title {
            font-size: 1.2rem;
            font-weight: 600;
            margin-bottom: 18px;
        }
        .category-filter {
            display: flex;
            gap: 8px;
            margin-bottom: 18px;
            flex-wrap: wrap;
        }
        .category-btn {
            background: var(--bg-alt);
            border: 1px solid var(--border);
            border-radius: 16px;
            padding: 5px 16px;
            font-size: 0.98rem;
            color: var(--text-light);
            cursor: pointer;
            transition: border 0.18s, color 0.18s, background 0.18s;
        }
        .category-btn.active, .category-btn:hover {
            border-color: var(--accent);
            color: #000;
            background: #eafffa;
        }
        .suggestion-item {
            background: var(--bg-alt);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 16px 14px;
            margin-bottom: 12px;
            font-size: 0.98rem;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        .suggestion-actions {
            display: flex;
            gap: 8px;
        }
        .suggestion-issue {
            text-decoration: line-through;
            color: #e74c3c;
        }
        .suggestion-suggestion {
            color: #00b894;
            font-weight: 600;
        }
        .suggestion-explanation {
            color: var(--text-light);
            font-size: 0.95rem;
        }
        .apply-all-btn {
            width: 100%;
            margin-top: 18px;
            background: var(--accent);
            color: #000;
            border: none;
            border-radius: 8px;
            padding: 10px 0;
            font-weight: 600;
            font-size: 1rem;
            cursor: pointer;
            transition: background 0.18s, color 0.18s;
        }
        .apply-all-btn:hover, .apply-all-btn:focus {
            background: #00e6ba;
            color: #111;
        }
        .error-message {
            background: #fff0f0;
            border: 1px solid #ffb3b3;
            color: #d32f2f;
            border-radius: 8px;
            padding: 12px 16px;
            margin-top: 18px;
            font-size: 1rem;
        }
        .notification {
            position: fixed;
            bottom: 32px;
            right: 32px;
            background: var(--accent);
            color: #000;
            padding: 14px 28px;
            border-radius: 12px;
            font-weight: 600;
            font-size: 1rem;
            box-shadow: 0 2px 16px 0 rgba(0,255,208,0.12);
            z-index: 1000;
        }
        /* Hide scrollbars for a cleaner look */
        ::-webkit-scrollbar {
            width: 8px;
            background: var(--bg-alt);
        }
        ::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 8px;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Header -->
        <div class="header">
            <div class="header-title">
                <span class="header-accent">
                    <!-- Accent SVG: simple geometric logo -->
                    <svg width="22" height="22" viewBox="0 0 22 22" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <rect x="2" y="2" width="18" height="18" rx="5" stroke="#000" stroke-width="2"/>
                        <circle cx="11" cy="11" r="4" stroke="#000" stroke-width="2"/>
                    </svg>
                </span>
                AI Writing Assistant
            </div>
            <div class="header-controls">
                <select id="apiBackend" class="select">
                    <option value="gemini">Gemini API</option>
                    <option value="openai">OpenAI API</option>
                    <option value="lmstudio">LM Studio</option>
                </select>
                <div id="apiKeyContainer" style="display: flex; align-items: center;">
                    <input type="password" id="apiKey" class="input" placeholder="Enter API key">
                </div>
                <button id="darkModeToggle" class="toggle-btn" title="Light mode only" disabled>
                    <svg width="20" height="20" viewBox="0 0 20 20" fill="none" stroke="#888" stroke-width="2"><circle cx="10" cy="10" r="7"/></svg>
                </button>
            </div>
        </div>
        <div class="main-grid">
            <!-- Editor Panel -->
            <div class="card">
                <div class="editor-toolbar">
                    <select id="fontSelect" class="select">
                        <option value="Inter">Inter</option>
                        <option value="Arial">Arial</option>
                        <option value="Times New Roman">Times New Roman</option>
                        <option value="Georgia">Georgia</option>
                        <option value="Verdana">Verdana</option>
                        <option value="Helvetica">Helvetica</option>
                        <option value="Courier New">Courier New</option>
                        <option value="Trebuchet MS">Trebuchet MS</option>
                        <option value="Comic Sans MS">Comic Sans MS</option>
                    </select>
                    <select id="sizeSelect" class="select">
                        <option value="13.33px">10</option>
                        <option value="14.67px">11</option>
                        <option value="16px" selected>12</option>
                        <option value="18.67px">14</option>
                        <option value="21.33px">16</option>
                        <option value="24px">18</option>
                        <option value="32px">24</option>
                        <option value="48px">36</option>
                    </select>
                    <button data-command="bold" class="toolbar-btn" title="Bold">
                        <svg viewBox="0 0 20 20" fill="none" stroke-width="2"><path d="M6 4h5a3 3 0 0 1 0 6H6zm0 6h6a3 3 0 0 1 0 6H6z" stroke="currentColor"/></svg>
                    </button>
                    <button data-command="italic" class="toolbar-btn" title="Italic">
                        <svg viewBox="0 0 20 20" fill="none" stroke-width="2"><path d="M10 4h4M6 16h4M14 4l-4 12" stroke="currentColor"/></svg>
                    </button>
                    <button data-command="underline" class="toolbar-btn" title="Underline">
                        <svg viewBox="0 0 20 20" fill="none" stroke-width="2"><path d="M6 4v6a4 4 0 0 0 8 0V4M4 18h12" stroke="currentColor"/></svg>
                    </button>
                    <button data-command="justifyLeft" class="toolbar-btn" title="Align Left">
                        <svg viewBox="0 0 20 20" fill="none" stroke-width="2"><path d="M4 6h12M4 10h8M4 14h12" stroke="currentColor"/></svg>
                    </button>
                    <button data-command="justifyCenter" class="toolbar-btn" title="Align Center">
                        <svg viewBox="0 0 20 20" fill="none" stroke-width="2"><path d="M4 6h12M7 10h6M4 14h12" stroke="currentColor"/></svg>
                    </button>
                    <button data-command="justifyRight" class="toolbar-btn" title="Align Right">
                        <svg viewBox="0 0 20 20" fill="none" stroke-width="2"><path d="M4 6h12M8 10h8M4 14h12" stroke="currentColor"/></svg>
                    </button>
                    <button data-command="insertUnorderedList" class="toolbar-btn" title="Bullet List">
                        <svg viewBox="0 0 20 20" fill="none" stroke-width="2"><circle cx="6" cy="7" r="1.5" stroke="currentColor"/><circle cx="6" cy="13" r="1.5" stroke="currentColor"/><path d="M10 7h6M10 13h6" stroke="currentColor"/></svg>
                    </button>
                    <button data-command="insertOrderedList" class="toolbar-btn" title="Numbered List">
                        <svg viewBox="0 0 20 20" fill="none" stroke-width="2"><text x="4" y="9" font-size="6" fill="currentColor">1.</text><text x="4" y="16" font-size="6" fill="currentColor">2.</text><path d="M10 7h6M10 13h6" stroke="currentColor"/></svg>
                    </button>
                    <button data-command="outdent" class="toolbar-btn" title="Outdent">
                        <svg viewBox="0 0 20 20" fill="none" stroke-width="2"><path d="M16 6v8M4 10h8M8 7l-4 3 4 3" stroke="currentColor"/></svg>
                    </button>
                    <button data-command="indent" class="toolbar-btn" title="Indent">
                        <svg viewBox="0 0 20 20" fill="none" stroke-width="2"><path d="M4 6v8M8 10h8M12 7l4 3-4 3" stroke="currentColor"/></svg>
                    </button>
                    <button id="colorBtn" class="toolbar-btn" title="Text Color">
                        <svg viewBox="0 0 20 20" fill="none" stroke-width="2"><path d="M6 15h8M10 4v8" stroke="currentColor"/></svg>
                    </button>
                    <button id="linkBtn" class="toolbar-btn" title="Insert Link">
                        <svg viewBox="0 0 20 20" fill="none" stroke-width="2"><path d="M7 13a5 5 0 0 1 0-7l1-1a5 5 0 0 1 7 7l-1 1" stroke="currentColor"/><path d="M13 7a5 5 0 0 1 0 7l-1 1a5 5 0 0 1-7-7l1-1" stroke="currentColor"/></svg>
                    </button>
                </div>
                <div id="editor" contenteditable="true" class="editor"></div>
                <div class="editor-actions">
                    <span id="charCount" class="char-count">0 characters</span>
                    <button id="analyzeBtn" class="btn-accent">Analyze Text</button>
                </div>
                <div id="errorMessage" class="error-message" style="display:none;"></div>
            </div>
            <!-- Suggestions Panel -->
            <div class="suggestions-panel">
                <div class="suggestions-title">Suggestions</div>
                <div id="categoryFilter" class="category-filter"></div>
                <div id="suggestionsContainer"></div>
                <button id="applyAllBtn" class="apply-all-btn" style="display:none;">Apply All Suggestions</button>
            </div>
        </div>
        <!-- Add missing color picker dropdown -->
        <div id="colorPicker" class="dropdown" style="display:none; position:absolute; z-index:1000; background:#fff; border:1px solid #e3e6ea; border-radius:10px; box-shadow:0 2px 16px 0 rgba(0,0,0,0.08); padding:12px;">
            <div class="grid" style="display:grid; grid-template-columns:repeat(5, 1fr); gap:6px;"></div>
        </div>
        <!-- Add missing applyAllContainer for suggestions -->
        <div id="applyAllContainer" style="display:none; margin-top:12px;">
            <button id="applyAllBtn" class="apply-all-btn">Apply All Suggestions</button>
        </div>
    </div>
    <!-- Link Dialog -->
    <div id="linkDialog" style="display:none; position:fixed; inset:0; background:rgba(0,0,0,0.18); z-index:100; align-items:center; justify-content:center;">
        <div style="background:#fff; border-radius:14px; padding:32px 28px; min-width:320px; box-shadow:0 2px 24px 0 rgba(0,0,0,0.10); display:flex; flex-direction:column; gap:16px; align-items:stretch;">
            <div style="font-size:1.1rem; font-weight:600;">Add Link</div>
            <input type="text" id="linkUrl" class="input" placeholder="Enter URL">
            <div style="display:flex; gap:10px; margin-top:8px;">
                <button id="addLinkBtn" class="btn-accent">Add</button>
                <button id="cancelLinkBtn" class="toggle-btn">Cancel</button>
            </div>
        </div>
    </div>
    <!-- Suggestion Tooltip (added for bug fix) -->
    <div id="suggestionTooltip" class="hidden" style="position:absolute; z-index:1000;"></div>
    <script>
        // State management
        let state = {
            text: '',
            htmlContent: '',
            suggestions: [],
            isAnalyzing: false,
            error: '',
            isDarkMode: false,
            activeCategory: 'all',
            activeTooltip: null,
            apiBackend: 'gemini',
            apiKey: ''
        };

        // Categories configuration
        const categories = [
            { id: 'all', label: 'All', color: 'bg-purple-500' },
            { id: 'grammar', label: 'Grammar', color: 'bg-blue-500' },
            { id: 'spelling', label: 'Spelling', color: 'bg-red-500' },
            { id: 'punctuation', label: 'Punctuation', color: 'bg-yellow-500' },
            { id: 'style', label: 'Style', color: 'bg-green-500' },
            { id: 'clarity', label: 'Clarity', color: 'bg-indigo-500' }
        ];

        const colors = [
            '#000000', '#FF0000', '#00FF00', '#0000FF', '#FFFF00',
            '#FF00FF', '#00FFFF', '#FFA500', '#800080', '#008000'
        ];

        const sampleTexts = [
            'Human welfare is at the heart of our work at Anthropic: our mission is to make sure that increasingly capable and sophisticated AI systems remain beneficial to humanity.\n\nBut as we build those AI systems, and as they begin to approximate or surpass many human qualities, another question arises. Should we also be concerned about the potential consciousness and experiences of the models themselves? Should we be concerned about *model welfare*, too?\n\nThis is an open question, and one that\'s both philosophically and scientifically difficult. But now that models can communicate, relate, plan, problem-solve, and pursue goals—along with very many more characteristics we associate with people—we think it\'s time to address it.\n\nTo that end, we recently started a research program to investigate, and prepare to navigate, model welfare.'
        ];

        // DOM elements
        const editor = document.getElementById('editor');
        const darkModeToggle = document.getElementById('darkModeToggle');
        // const loadSampleBtn = document.getElementById('loadSampleBtn'); // REMOVED
        // const copyBtn = document.getElementById('copyBtn'); // REMOVED
        const analyzeBtn = document.getElementById('analyzeBtn');
        const charCount = document.getElementById('charCount');
        const errorMessage = document.getElementById('errorMessage');
        const suggestionsContainer = document.getElementById('suggestionsContainer');
        const categoryFilter = document.getElementById('categoryFilter');
        const applyAllContainer = document.getElementById('applyAllContainer');
        const applyAllBtn = document.getElementById('applyAllBtn');
        const colorPicker = document.getElementById('colorPicker');
        const colorBtn = document.getElementById('colorBtn');
        const lineSpacingBtn = document.getElementById('lineSpacingBtn');
        const lineSpacingPicker = document.getElementById('lineSpacingPicker');
        const linkBtn = document.getElementById('linkBtn');
        const linkDialog = document.getElementById('linkDialog');
        const linkUrl = document.getElementById('linkUrl');
        const addLinkBtn = document.getElementById('addLinkBtn');
        const cancelLinkBtn = document.getElementById('cancelLinkBtn');
        const suggestionTooltip = document.getElementById('suggestionTooltip');
        const fontSelect = document.getElementById('fontSelect');
        const sizeSelect = document.getElementById('sizeSelect');
        const apiBackend = document.getElementById('apiBackend');
        const apiKey = document.getElementById('apiKey');
        const apiKeyContainer = document.getElementById('apiKeyContainer');

        // Initialize
        function init() {
            setupEventListeners();
            renderCategories();
            renderColorPicker();
            updateApiBackendUI();
            
            // Load saved API settings (API key should NOT be loaded or saved)
            const savedBackend = localStorage.getItem('apiBackend');
            if (savedBackend) {
                apiBackend.value = savedBackend;
                state.apiBackend = savedBackend;
            }
            // Do NOT load or set apiKey from localStorage
            apiKey.value = '';
            state.apiKey = '';
        }

        // Setup event listeners
        function setupEventListeners() {
            editor.addEventListener('input', updateContent);
            editor.addEventListener('paste', handlePaste);
            editor.addEventListener('copy', handleCopy);
            editor.addEventListener('click', handleEditorClick);
            
            darkModeToggle.addEventListener('click', toggleDarkMode);
            // if (loadSampleBtn) loadSampleBtn.addEventListener('click', loadSampleText); // REMOVED
            // if (copyBtn) copyBtn.addEventListener('click', copyText); // REMOVED
            analyzeBtn.addEventListener('click', analyzeText);
            applyAllBtn.addEventListener('click', applyAllSuggestions);
            
            // API backend handlers
            apiBackend.addEventListener('change', (e) => {
                state.apiBackend = e.target.value;
                localStorage.setItem('apiBackend', e.target.value);
                updateApiBackendUI();
            });
            
            apiKey.addEventListener('input', (e) => {
                state.apiKey = e.target.value;
                // Do NOT save apiKey to localStorage
            });
            
            // Toolbar buttons
            document.querySelectorAll('.toolbar-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const command = btn.dataset.command;
                    formatText(command);
                });
            });
            
            // Font and size selects
            fontSelect.addEventListener('change', (e) => formatText('fontName', e.target.value));
            sizeSelect.addEventListener('change', (e) => formatText('fontSize', e.target.value));
            
            // Color picker
            if (colorBtn && colorPicker) {
                colorBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    toggleDropdown(colorPicker);
                });
            }
            
            // Line spacing
            if (lineSpacingBtn && lineSpacingPicker) {
                lineSpacingBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    toggleDropdown(lineSpacingPicker);
                });
            }
            
            document.querySelectorAll('[data-spacing]').forEach(btn => {
                btn.addEventListener('click', () => {
                    editor.style.lineHeight = btn.dataset.spacing;
                    if (lineSpacingPicker) lineSpacingPicker.classList.remove('show');
                });
            });
            
            // Link dialog
            if (linkBtn && linkDialog && addLinkBtn && cancelLinkBtn && linkUrl) {
                linkBtn.addEventListener('click', () => linkDialog.classList.remove('hidden'));
                addLinkBtn.addEventListener('click', insertLink);
                cancelLinkBtn.addEventListener('click', () => {
                    linkDialog.classList.add('hidden');
                    linkUrl.value = '';
                });
            }
            
            // Close dropdowns on outside click
            document.addEventListener('click', (e) => {
                if (colorBtn && colorPicker && !colorBtn.contains(e.target) && !colorPicker.contains(e.target)) {
                    colorPicker.classList.remove('show');
                }
                if (lineSpacingBtn && lineSpacingPicker && !lineSpacingBtn.contains(e.target) && !lineSpacingPicker.contains(e.target)) {
                    lineSpacingPicker.classList.remove('show');
                }
                if (suggestionTooltip && !suggestionTooltip.contains(e.target) && e.target.tagName !== 'MARK') {
                    hideSuggestionTooltip();
                }
            });
        }

        // Update API backend UI
        function updateApiBackendUI() {
            if (state.apiBackend === 'lmstudio') {
                apiKeyContainer.style.display = 'none';
            } else {
                apiKeyContainer.style.display = 'flex';
                apiKey.placeholder = state.apiBackend === 'gemini' ? 'Enter Gemini API key' : 'Enter OpenAI API key';
            }
        }

        // Render categories
        function renderCategories() {
            categoryFilter.innerHTML = categories.map(category => `
                <button data-category="${category.id}" 
                        class="category-btn px-3 py-1 rounded-full text-sm font-medium transition-all ${
                            state.activeCategory === category.id 
                                ? `${category.color} text-white` 
                                : 'bg-gray-100 text-gray-700 hover:bg-gray-200'
                        }">
                    ${category.label}
                    <span class="category-count ml-1"></span>
                </button>
            `).join('');
            
            document.querySelectorAll('.category-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    state.activeCategory = btn.dataset.category;
                    renderCategories();
                    renderSuggestions();
                });
            });
        }

        // Render color picker
        function renderColorPicker() {
            const colorGrid = colorPicker.querySelector('.grid');
            colorGrid.innerHTML = colors.map(color => `
                <button data-color="${color}" 
                        class="w-6 h-6 rounded border border-gray-400"
                        style="background-color: ${color}"></button>
            `).join('');
            
            colorGrid.querySelectorAll('button').forEach(btn => {
                btn.addEventListener('click', () => {
                    formatText('foreColor', btn.dataset.color);
                    colorPicker.classList.remove('show');
                });
            });
        }

        // Toggle dropdown
        function toggleDropdown(dropdown) {
            dropdown.classList.toggle('show');
        }

        // Update content
        function updateContent() {
            state.htmlContent = editor.innerHTML;
            
            // Extract plain text
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = state.htmlContent;
            
            // Remove mark tags
            tempDiv.querySelectorAll('mark').forEach(mark => {
                const textNode = document.createTextNode(mark.textContent);
                mark.parentNode.replaceChild(textNode, mark);
            });
            
            // Convert br to newlines
            tempDiv.innerHTML = tempDiv.innerHTML.replace(/<br\s*\/?>/gi, '\n');
            
            state.text = tempDiv.textContent || '';
            charCount.textContent = `${state.text.length} characters`;
            
            hideSuggestionTooltip();
        }

        // Format text
        function formatText(command, value = null) {
            if (command === 'fontSize') {
                const selection = window.getSelection();
                if (!selection.rangeCount) return;
                
                const range = selection.getRangeAt(0);
                
                if (range.collapsed) {
                    editor.style.fontSize = value;
                } else {
                    try {
                        const contents = range.extractContents();
                        const span = document.createElement('span');
                        span.style.fontSize = value;
                        
                        while (contents.firstChild) {
                            span.appendChild(contents.firstChild);
                        }
                        
                        range.insertNode(span);
                        range.selectNodeContents(span);
                        selection.removeAllRanges();
                        selection.addRange(range);
                    } catch (e) {
                        document.execCommand('fontSize', false, '7');
                        editor.querySelectorAll('font[size="7"]').forEach(font => {
                            const span = document.createElement('span');
                            span.style.fontSize = value;
                            span.innerHTML = font.innerHTML;
                            font.parentNode.replaceChild(span, font);
                        });
                    }
                }
            } else {
                document.execCommand(command, false, value);
            }
            
            editor.focus();
            updateContent();
        }

        // Handle paste
        function handlePaste(e) {
            e.preventDefault();
            
            const text = e.clipboardData.getData('text/plain');
            const paragraphs = text.split('\n\n').map(p => p.trim()).filter(p => p);
            const cleanHTML = paragraphs
                .map(p => {
                    const withBreaks = p.replace(/\n/g, '<br>');
                    return `<span style="font-family: Arial; font-size: 16px;">${withBreaks}</span>`;
                })
                .join('<br><br>');
            
            const selection = window.getSelection();
            if (!selection.rangeCount) return;
            
            selection.deleteFromDocument();
            const range = selection.getRangeAt(0);
            const fragment = range.createContextualFragment(cleanHTML);
            range.insertNode(fragment);
            
            range.collapse(false);
            selection.removeAllRanges();
            selection.addRange(range);
            
            updateContent();
        }

        // Handle copy
        function handleCopy(e) {
            const selection = window.getSelection();
            if (selection.rangeCount === 0) return;
            
            const range = selection.getRangeAt(0);
            const clonedSelection = range.cloneContents();
            
            const tempDiv = document.createElement('div');
            tempDiv.appendChild(clonedSelection);
            
            // Remove marks and backgrounds
            tempDiv.querySelectorAll('mark').forEach(mark => {
                const span = document.createElement('span');
                span.innerHTML = mark.innerHTML;
                mark.parentNode.replaceChild(span, mark);
            });
            
            tempDiv.querySelectorAll('*').forEach(el => {
                if (el.style) {
                    el.style.backgroundColor = '';
                    el.style.background = '';
                }
            });
            
            e.clipboardData.setData('text/plain', tempDiv.textContent);
            e.clipboardData.setData('text/html', tempDiv.innerHTML);
            e.preventDefault();
        }

        // Handle editor click
        function handleEditorClick(e) {
            if (e.target.tagName === 'MARK') {
                const issueText = decodeURIComponent(e.target.getAttribute('data-issue') || '');
                showSuggestionTooltip(e, issueText);
            }
        }

        // Toggle dark mode
        function toggleDarkMode() {
            state.isDarkMode = !state.isDarkMode;
            document.body.classList.toggle('bg-gray-900');
            document.body.classList.toggle('bg-gray-50');
            
            // Update all theme-dependent elements
            const elements = document.querySelectorAll('[class*="bg-white"], [class*="text-gray-"], [class*="border-gray-"], [class*="bg-gray-"]');
            elements.forEach(el => {
                // This is a simplified version - in production, you'd want more sophisticated theme switching
                el.className = el.className.replace(/bg-white/g, state.isDarkMode ? 'bg-gray-800' : 'bg-white');
                el.className = el.className.replace(/text-gray-900/g, state.isDarkMode ? 'text-white' : 'text-gray-900');
            });
            
            darkModeToggle.innerHTML = state.isDarkMode ? '<i class="fas fa-sun"></i>' : '<i class="fas fa-moon"></i>';
        }

        // Load sample text
        function loadSampleText() {
            const randomSample = sampleTexts[Math.floor(Math.random() * sampleTexts.length)];
            const paragraphs = randomSample.split('\n\n').map(p => p.trim()).filter(p => p);
            const htmlContent = paragraphs
                .map(p => `<span style="font-family: Arial; font-size: 16px;">${p}</span>`)
                .join('<br><br>');
            
            editor.innerHTML = htmlContent;
            updateContent();
        }

        // Copy text
        function copyText() {
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = editor.innerHTML;
            tempDiv.style.position = 'absolute';
            tempDiv.style.left = '-9999px';
            tempDiv.style.whiteSpace = 'pre-wrap';
            document.body.appendChild(tempDiv);
            
            // Remove marks
            tempDiv.querySelectorAll('mark').forEach(mark => {
                const span = document.createElement('span');
                span.innerHTML = mark.innerHTML;
                mark.parentNode.replaceChild(span, mark);
            });
            
            // Remove backgrounds
            tempDiv.querySelectorAll('*').forEach(el => {
                if (el.style) {
                    el.style.backgroundColor = '';
                    el.style.background = '';
                }
            });
            
            const selection = window.getSelection();
            const range = document.createRange();
            range.selectNodeContents(tempDiv);
            selection.removeAllRanges();
            selection.addRange(range);
            
            try {
                document.execCommand('copy');
                selection.removeAllRanges();
                document.body.removeChild(tempDiv);
                showNotification('Text copied!');
            } catch (err) {
                document.body.removeChild(tempDiv);
                navigator.clipboard.writeText(state.text);
            }
        }

        // Insert link
        function insertLink() {
            if (linkUrl.value) {
                formatText('createLink', linkUrl.value);
                linkDialog.classList.add('hidden');
                linkUrl.value = '';
            }
        }

        // Show error
        function showError(message) {
            state.error = message;
            errorMessage.textContent = message; // FIXED: Don't assume <p> exists
            errorMessage.classList.remove('hidden');
        }

        // Hide error
        function hideError() {
            state.error = '';
            errorMessage.classList.add('hidden');
        }

        // Show notification
        function showNotification(message) {
            // Simple notification - in production, you'd want a better toast component
            const notification = document.createElement('div');
            notification.className = 'fixed bottom-4 right-4 bg-green-500 text-white px-4 py-2 rounded-lg shadow-lg z-50';
            notification.textContent = message;
            document.body.appendChild(notification);
            
            setTimeout(() => {
                notification.remove();
            }, 2000);
        }

        // API calls for different backends
        async function callGeminiAPI(prompt) {
            // NOTE: If you get a 404 or auth error, check your Gemini API key and endpoint here!
            const response = await fetch('https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=' + state.apiKey, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    contents: [{
                        parts: [{
                            text: prompt
                        }]
                    }]
                })
            });
            
            if (!response.ok) {
                throw new Error('Gemini API error: ' + response.statusText);
            }
            
            const data = await response.json();
            return data.candidates[0].content.parts[0].text;
        }

        async function callOpenAIAPI(prompt) {
            const response = await fetch('https://api.openai.com/v1/chat/completions', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': 'Bearer ' + state.apiKey
                },
                body: JSON.stringify({
                    model: 'gpt-3.5-turbo',
                    messages: [{
                        role: 'user',
                        content: prompt
                    }],
                    temperature: 0.7
                })
            });
            
            if (!response.ok) {
                throw new Error('OpenAI API error: ' + response.statusText);
            }
            
            const data = await response.json();
            return data.choices[0].message.content;
        }

        async function callLMStudioAPI(prompt) {
            const response = await fetch('http://localhost:1234/v1/chat/completions', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    messages: [{
                        role: 'user',
                        content: prompt
                    }],
                    temperature: 0.7
                })
            });
            
            if (!response.ok) {
                throw new Error('LM Studio API error: ' + response.statusText);
            }
            
            const data = await response.json();
            return data.choices[0].message.content;
        }

        // Analyze text
        async function analyzeText() {
            // Clear highlights
            let content = editor.innerHTML;
            content = content.replace(/<mark[^>]*>(.*?)<\/mark>/g, '$1');
            editor.innerHTML = content;
            updateContent();
            
            if (!state.text.trim()) {
                showError('Please enter some text to analyze');
                return;
            }
            
            if (state.apiBackend !== 'lmstudio' && !state.apiKey) {
                showError('Please enter your API key');
                return;
            }
            
            state.isAnalyzing = true;
            hideError();
            state.suggestions = [];
            
            analyzeBtn.disabled = true;
            analyzeBtn.innerHTML = '<i class="fas fa-spinner animate-spin"></i> Analyzing...';
            
            try {
                const prompt = `Analyze the following text and provide specific suggestions for improvement. Focus on grammar, spelling, punctuation, style, and clarity. 

Text to analyze:
"${state.text}"

IMPORTANT: When identifying issues, preserve the EXACT text including all quotation marks, apostrophes, and special characters. For example, if the text contains "consumers" with quotes, the issue field should be "consumers" not consumers.

Respond with a JSON array of suggestion objects. Each object should have:
- category: one of "grammar", "spelling", "punctuation", "style", or "clarity"
- issue: the EXACT text that needs improvement (including any quotes or special characters)
- suggestion: the corrected or improved version
- explanation: a brief explanation of why this change improves the text
- position: approximate starting position in the text (character index)

Only include actual issues that need correction. If the text is perfect, return an empty array.

Your entire response must be a valid JSON array. DO NOT include any text outside the JSON structure.`;

                let response;
                switch (state.apiBackend) {
                    case 'gemini':
                        response = await callGeminiAPI(prompt);
                        break;
                    case 'openai':
                        response = await callOpenAIAPI(prompt);
                        break;
                    case 'lmstudio':
                        response = await callLMStudioAPI(prompt);
                        break;
                }
                
                // Extract JSON from response (some APIs may include markdown formatting)
                const jsonMatch = response.match(/\[[\s\S]*\]/);
                if (jsonMatch) {
                    response = jsonMatch[0];
                }
                
                const parsedSuggestions = JSON.parse(response);
                if (Array.isArray(parsedSuggestions)) {
                    state.suggestions = parsedSuggestions;
                    applyHighlights();
                    renderSuggestions();
                } else {
                    throw new Error('Invalid response format');
                }
            } catch (err) {
                console.error('Analysis error:', err);
                showError('Failed to analyze text. Please check your API key and try again.');
            } finally {
                state.isAnalyzing = false;
                analyzeBtn.disabled = false;
                analyzeBtn.innerHTML = '<i class="fas fa-sparkles"></i> Analyze Text';
            }
        }

        // Apply highlights
        function applyHighlights() {
            let content = editor.innerHTML;
            content = content.replace(/<mark[^>]*>(.*?)<\/mark>/g, '$1');
            
            if (state.suggestions.length === 0) {
                editor.innerHTML = content;
                return;
            }
            
            const categoryColors = {
                grammar: 'rgba(59, 130, 246, 0.3)',
                spelling: 'rgba(239, 68, 68, 0.3)',
                punctuation: 'rgba(245, 158, 11, 0.3)',
                style: 'rgba(34, 197, 94, 0.3)',
                clarity: 'rgba(99, 102, 241, 0.3)'
            };
            
            state.suggestions.forEach(suggestion => {
                const color = categoryColors[suggestion.category] || 'rgba(147, 51, 234, 0.3)';
                const issueText = suggestion.issue;
                const escapedIssue = escapeHtml(issueText);
                
                const patterns = [
                    issueText,
                    escapedIssue,
                    issueText.replace(/"/g, '&quot;').replace(/'/g, '&#039;')
                ];
                
                for (const pattern of patterns) {
                    if (content.includes(pattern)) {
                        content = content.replace(
                            pattern,
                            `<mark data-issue="${encodeURIComponent(issueText)}" style="background-color: ${color}; padding: 2px 0; border-radius: 2px;">${pattern}</mark>`
                        );
                        break;
                    }
                }
            });
            
            editor.innerHTML = content;
        }

        // Escape HTML
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Render suggestions
        function renderSuggestions() {
            const filteredSuggestions = state.activeCategory === 'all' 
                ? state.suggestions 
                : state.suggestions.filter(s => s.category === state.activeCategory);
            
            // Update category counts
            document.querySelectorAll('.category-count').forEach((span, index) => {
                const category = categories[index];
                const count = state.suggestions.filter(s => category.id === 'all' || s.category === category.id).length;
                span.textContent = count > 0 ? `(${count})` : '';
            });
            
            if (filteredSuggestions.length === 0) {
                suggestionsContainer.innerHTML = `
                    <div class="text-center py-12 text-gray-400">
                        ${state.suggestions.length === 0 
                            ? "Click 'Analyze Text' to get suggestions"
                            : "No suggestions in this category"}
                    </div>
                `;
                applyAllContainer.classList.add('hidden');
            } else {
                suggestionsContainer.innerHTML = filteredSuggestions.map((suggestion, index) => `
                    <div class="suggestion-item p-4 rounded-lg border bg-gray-50 border-gray-200 hover:border-gray-300 transition-all hover:shadow-md">
                        <div class="flex justify-between items-start mb-2">
                            <div class="flex items-center gap-2">
                                <span class="inline-block px-2 py-1 rounded-full text-xs font-medium text-white ${getCategoryColor(suggestion.category)}">
                                    ${suggestion.category}
                                </span>
                                <div class="w-3 h-3 rounded-full" style="background-color: ${getCategoryColorRgba(suggestion.category)}" title="Text highlight color"></div>
                            </div>
                            <div class="flex gap-1">
                                <button onclick="applySuggestion(${index})" class="p-1 rounded hover:bg-green-500/20 text-green-500 transition-colors" title="Apply suggestion">
                                    <i class="fas fa-check"></i>
                                </button>
                                <button onclick="dismissSuggestion(${index})" class="p-1 rounded hover:bg-red-500/20 text-red-500 transition-colors" title="Dismiss">
                                    <i class="fas fa-times"></i>
                                </button>
                            </div>
                        </div>
                        
                        <div class="space-y-2">
                            <div class="flex items-center gap-2 text-sm">
                                <span class="line-through text-red-600">${suggestion.issue}</span>
                                <span class="text-gray-400">→</span>
                                <span class="font-medium text-green-600">${suggestion.suggestion}</span>
                            </div>
                            
                            <p class="text-sm text-gray-600">${suggestion.explanation}</p>
                        </div>
                    </div>
                `).join('');
                
                if (state.suggestions.length > 0) {
                    applyAllContainer.classList.remove('hidden');
                }
            }
        }

        // Get category color
        function getCategoryColor(categoryId) {
            const category = categories.find(c => c.id === categoryId);
            return category ? category.color : 'bg-gray-500';
        }

        // Get category color RGBA
        function getCategoryColorRgba(category) {
            const colors = {
                grammar: 'rgba(59, 130, 246, 0.5)',
                spelling: 'rgba(239, 68, 68, 0.5)',
                punctuation: 'rgba(245, 158, 11, 0.5)',
                style: 'rgba(34, 197, 94, 0.5)',
                clarity: 'rgba(99, 102, 241, 0.5)'
            };
            return colors[category] || 'rgba(147, 51, 234, 0.5)';
        }

        // Apply suggestion
        function applySuggestion(index) {
            const suggestion = state.activeCategory === 'all' 
                ? state.suggestions[index]
                : state.suggestions.filter(s => s.category === state.activeCategory)[index];
            
            if (!suggestion) return;
            
            let content = editor.innerHTML;
            content = content.replace(/<mark[^>]*>(.*?)<\/mark>/g, '$1');
            
            const patterns = [
                suggestion.issue,
                escapeHtml(suggestion.issue),
                suggestion.issue.replace(/"/g, '&quot;').replace(/'/g, '&#039;')
            ];
            
            for (const pattern of patterns) {
                if (content.includes(pattern)) {
                    content = content.replace(pattern, escapeHtml(suggestion.suggestion));
                    break;
                }
            }
            
            editor.innerHTML = content;
            updateContent();
            
            state.suggestions = state.suggestions.filter(s => s !== suggestion);
            applyHighlights();
            renderSuggestions();
            hideSuggestionTooltip();
        }

        // Dismiss suggestion
        function dismissSuggestion(index) {
            const suggestion = state.activeCategory === 'all' 
                ? state.suggestions[index]
                : state.suggestions.filter(s => s.category === state.activeCategory)[index];
            
            if (!suggestion) return;
            
            state.suggestions = state.suggestions.filter(s => s !== suggestion);
            applyHighlights();
            renderSuggestions();
            hideSuggestionTooltip();
        }

        // Apply all suggestions
        function applyAllSuggestions() {
            let content = editor.innerHTML;
            content = content.replace(/<mark[^>]*>(.*?)<\/mark>/g, '$1');
            
            state.suggestions.forEach(suggestion => {
                const patterns = [
                    suggestion.issue,
                    escapeHtml(suggestion.issue),
                    suggestion.issue.replace(/"/g, '&quot;').replace(/'/g, '&#039;')
                ];
                
                for (const pattern of patterns) {
                    if (content.includes(pattern)) {
                        content = content.replace(pattern, escapeHtml(suggestion.suggestion));
                        break;
                    }
                }
            });
            
            editor.innerHTML = content;
            updateContent();
            
            state.suggestions = [];
            renderSuggestions();
        }

        // Show suggestion tooltip
        function showSuggestionTooltip(e, issueText) {
            const matchingSuggestion = state.suggestions.find(s => s.issue === issueText);
            if (!matchingSuggestion) return;
            
            const rect = e.target.getBoundingClientRect();
            const editorRect = editor.getBoundingClientRect();
            
            let top = rect.top - editorRect.top - 10;
            let left = rect.left - editorRect.left + (rect.width / 2);
            let isBelow = false;
            
            if (top < 100) {
                top = rect.bottom - editorRect.top + 10;
                isBelow = true;
            }
            
            const tooltipWidth = 300;
            if (left - tooltipWidth/2 < 10) {
                left = tooltipWidth/2 + 10;
            } else if (left + tooltipWidth/2 > editorRect.width - 10) {
                left = editorRect.width - tooltipWidth/2 - 10;
            }
            
            state.activeTooltip = matchingSuggestion;
            
            suggestionTooltip.innerHTML = `
                <div class="flex items-center gap-2 mb-2">
                    <span class="inline-block px-2 py-1 rounded-full text-xs font-medium text-white ${getCategoryColor(matchingSuggestion.category)}">
                        ${matchingSuggestion.category}
                    </span>
                </div>
                
                <div class="space-y-2 mb-3">
                    <div class="flex items-center gap-2 text-sm">
                        <span class="line-through text-red-600">${matchingSuggestion.issue}</span>
                        <span class="text-gray-400">→</span>
                        <span class="font-medium text-green-600">${matchingSuggestion.suggestion}</span>
                    </div>
                    
                    <p class="text-sm text-gray-600">${matchingSuggestion.explanation}</p>
                </div>
                
                <div class="flex gap-2">
                    <button onclick="applyTooltipSuggestion()" class="px-3 py-1 bg-green-500 text-white rounded text-sm hover:bg-green-600 transition-colors">
                        Accept
                    </button>
                    <button onclick="dismissTooltipSuggestion()" class="px-3 py-1 bg-red-500 text-white rounded text-sm hover:bg-red-600 transition-colors">
                        Reject
                    </button>
                    <button onclick="hideSuggestionTooltip()" class="px-3 py-1 rounded text-sm bg-gray-200 text-gray-700 hover:bg-gray-300 transition-colors">
                        Cancel
                    </button>
                </div>
                
                <div class="tooltip-arrow absolute w-3 h-3 transform rotate-45 bg-white ${
                    isBelow ? 'top-[-6px] border-l border-t border-gray-200' : 'bottom-[-6px] border-r border-b border-gray-200'
                }" style="left: 50%; transform: translateX(-50%) rotate(45deg);"></div>
            `;
            
            suggestionTooltip.style.top = `${top}px`;
            suggestionTooltip.style.left = `${left}px`;
            suggestionTooltip.style.transform = isBelow ? 'translateX(-50%)' : 'translate(-50%, -100%)';
            suggestionTooltip.classList.remove('hidden');
        }

        // Hide suggestion tooltip
        function hideSuggestionTooltip() {
            suggestionTooltip.classList.add('hidden');
            state.activeTooltip = null;
        }

        // Apply tooltip suggestion
        function applyTooltipSuggestion() {
            if (!state.activeTooltip) return;
            
            const index = state.suggestions.findIndex(s => s === state.activeTooltip);
            if (index !== -1) {
                applySuggestion(index);
            }
        }

        // Dismiss tooltip suggestion
        function dismissTooltipSuggestion() {
            if (!state.activeTooltip) return;
            
            const index = state.suggestions.findIndex(s => s === state.activeTooltip);
            if (index !== -1) {
                dismissSuggestion(index);
            }
        }

        // Initialize the app
        init();
    </script>
</body>
</html>
